各类平衡搜索二叉树的总结：
1.AVL树：最为经典的平衡树，其以显式的平衡因子来保证其树的平衡性。其查找算法与普通的二叉搜索树别无二致。但是在插入新节点时，可能会使得某个祖先辈节点失衡。
需要根据情况做相应的旋转调整。代码实现时利用了3+4重构的方法。同理，删除节点时，也会导致失衡，且失衡现象可能会向上传播。但是重平衡策略并未改变。亦即重复利用3+4重构即可恢复
整棵树的平衡。此类平衡二叉树需要时刻检查并维护各个节点的平衡因子。因此代码编写复杂。并且其对平衡性的要求过于严苛。
-----------------------------------------------------------------------------------------------------------------------------------------------------------
2.Splay树：伸展树,相比于AVL树，其不需要维持各个节点的平衡因子的信息。故实现起来更为简洁。其无法保持整棵树在动态操作的平衡性，但是在分摊意义上，各类操作亦可以
在O(logN)的时间内完成。其设计目的及思想主要是基于数据局部性的角度予以考虑。
2.1刚刚被访问的元素，极有可能在不久后被再次访问。
2.2即将被访问的某一节点，极有可能就处于不久之前被访问过的某个节点附近。
基于此，Splay树采用旋转的方式，将访问过的节点及其附近节点推至树的顶部。以便于下一次的访问。其旋转的方式如AVL树一样，主要采用zig-zig zag-zag zig-zag zag-zig等
四种方式。其精髓和与AVL树的不同之处主要在于zig-zig zag-zag等双层伸展可以使得目标节点所在的分支快速减半。
ps:提供的delete insert代码实现并非最佳实践。
-----------------------------------------------------------------------------------------------------------------------------------------------------------
3.B-树：亦称之为多路(2^k)搜索树，将k层的节点合并成一个大节点，主要为了解决内外存在读写速度上的不一致而引起的矛盾。具体来讲，一次外部访问所花费的时间是一次内部访问所花费的时间的5-6个数量级。更为重要的是,从外存一次批量读取和
单个读取所花时间相差不大，故为了提高访问效率，应该将内外存的访问频率有机的协调起来。取二者之长。例如，一次多从外存读取记录，并且减少读取次数。
m阶B-树是指每个大节点所包含的最多分支数目。可以证明，其树高为O(logmN)。故其查找,插入与删除的时间均在O(logmN)。
调整算法：
3.1上溢与分裂
其在插入时可能会出现上溢的现象，此时将上溢的节点向上插入其父节点，并将上溢的大节点一分为二，若正好父辈节点足以容纳该上溢的节点，则宣告完毕，否则，对父节点采取相同的操作，
最坏情况上溢h次，并产生新的根节点。
3.2下溢与合并
同样其在删除时，可能会出现下溢的现象。此时若可能则向父节点借一个节点插入其中，并从其兄弟中取出一个节点还给父亲。(这样做略显繁杂，主要原因是考虑了二叉搜索树的中序遍历的顺序性)若无力偿还，则其与将从父亲借的节点和其兄弟三者合并为一个大节点。
----------------------------------------------------------------------------------------------------------------------------------------------------------------
4.红黑树：每个节点附加了颜色的信息，且需要满足以下3点条件，方是一颗红黑树。
(1.树根以及外部节点为黑色。(2.其余节点若为红色，则其孩子必为黑色。(3.从任一外部节点到根节点的沿途，黑节点数目必然相等。
可以证明树的高度在log(N+1)到2*log(N+1)之间，故渐进意义上是平衡的，亦满足平衡搜索树的相关操作的时间性能。
相比于AVL树，其在每次操作后，树的拓扑结构的调整在分摊意义下为O(1).其维持平衡性的条件大致为：任一节点的左右子树的高度相差不超过两倍(根据性质三推出)。
代码实现十分复杂。略。
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
